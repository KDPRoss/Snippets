I've long been fascinated by the idea of taking two
programming languages and ‘mating’ them to produce
‘linguistic offspring’, by which I, essentially, mean
combining features from the ‘parent’ languages to create
a novel language.

At last, I've actually done that, sourcing syntax from
Tanager (with necessary modifications) and semantics from
Motmot to create ‘Motmot B’. In both cases, the
surface-level code is translated to Motmot Core, and the
same type checker and evaluator handles both.

Here is some matched code in Tanager, Motmot (a.k.a.,
‘Motmot A’ ), and Motmot B The primary dimensions of
distinction to examine are:
- Explicit vs implicit typing.
- Linear vs block syntax.
- Assorted syntactic / naming idiosyncracies.

We'll ignore mixfix definitions, which look different
between Tanager and Motmot but are fundamentally
equivalent … and not very interesting.

Tanager                                                                                  | Motmot B                                                                                                                               | Motmot A
                                                                                         |                                                                                                                                        |
typedef Letter = String                                                                  | typedef Letter = String                                                                                                                | typedef Letter = String
                                                                                         |                                                                                                                                        |
typedef Letters = [ Letter ]                                                             | typedef Letters = [ Letter ]                                                                                                           | typedef Letters = [ Letter ]
                                                                                         |                                                                                                                                        |
-- Unlike in the Motmot, we can only abstract over                                       |                                                                                                                                        |
-- `*`-kinded types (hence, no kind annotation), and type                                |                                                                                                                                        |
-- variables are on the LHS of `=` (because they,                                        |                                                                                                                                        |
-- syntactically, can't be abstracted in a type).                                        |                                                                                                                                        |
typedef Parser result = Letters -> [ (result, Letters) ]                                 | typedef Parser  = (result : *) => Letters -> [ (result, Letters)                                                                       | typedef Parser  = (result : *) => Letters -> [ (result, Letters) ]
                                                                                         |                                                                                                                                        |
succeed   : result -> Parser result                                                      | succeed                          : (result : *) => result -> Parser result                                                             | succeed : (result : *) => result -> Parser result =
... v inp = [ (v, inp) ]                                                                 | ... (v : result) (inp : Letters) = [ (v, inp) ]                                                                                        |   (result : *) =>
                                                                                         |                                                                                                                                        |     (v : result) | (inp : Letters) ~ [ (v, inp) ]
                                                                                         |                                                                                                                                        |
fail-parse : Parser result                                                               | fail-parse : (result : *) => Parser result                                                                                             | fail-parse : (result : *) => Parser result =
...        = const []                                                                    | ...        = const{ Letters } [{ (result, Letters) }]                                                                                  |   (result : *) =>
                                                                                         |                                                                                                                                        |     const{ Letters } [{ (result, Letters) }]
                                                                                         |                                                                                                                                        |
-- Had to refactor this function because of a scoping                                    |                                                                                                                                        |
-- difference between Motmot and Tanager: `p` wouldn't be                                |                                                                                                                                        |
-- in-scope in the predicate pattern if we used the                                      |                                                                                                                                        |
-- Motmot-style destructuring.                                                           |                                                                                                                                        |
satisfy : (Letter -> Bool) -> Parser Letter                                              | satisfy                                                             : (Letter -> Bool) -> Parser Letter                                | satisfy : (Letter -> Bool) -> Parser Letter =
... p   = fun                                                                            | ... (_ : Letter -> Bool) [{ Letter }]                               = [{ (Letter, Letters) }]                                          |   (p : Letter -> Bool) ~
            []                  -> []                                                    | ... (p : Letter -> Bool) (((x : Letter) and {p}) :: (xs : Letters)) = succeed x xs                                                     |     case of
            ((x & <(p)>) :: xs) -> succeed x xs                                          | ... (_ : Letter -> Bool) (ls : Letters)                             = fail-parse{ Letter } ls                                          |     ([{ Letter }]                           ~ [{ (Letter, Letters) }])
            ls                  -> fail-parse ls                                         |                                                                                                                                        |     (((x : Letter) and {p}) :: (xs : Letters) ~ succeed x xs)
                                                                                         |                                                                                                                                        |     fail-parse{ Letter }
                                                                                         |                                                                                                                                        |
literal : Letter -> Parser Letter                                                        | literal          : Letter -> Parser Letter                                                                                             | literal : Letter -> Parser Letter =
... x   = satisfy (x == _)                                                               | ... (x : Letter) = satisfy (x == _)                                                                                                    |   (x : Letter) ~ satisfy (x == _)
                                                                                         |                                                                                                                                        |
                                                                                         | -- Motmot has ‘exotic’ `~`-delimited λs.                                                                                               |
||        : Parser a -> Parser a -> Parser a                                             | ||                                  : (a : *) => Parser a -> Parser a -> Parser a                                                      | || : (a : *) => Parser a -> Parser a -> Parser a =
... p1 p2 = \ inp -> p1 inp ++ p2 inp                                                    | ... (p1 : Parser a) (p2 : Parser a) = (inp : Letters) ~ p1 inp ++ p2 inp                                                               |   (a : *) =>
                                                                                         |                                                                                                                                        |     (p1 : Parser a) | (p2 : Parser a) ~
                                                                                         |                                                                                                                                        |       (inp : Letters) ~ p1 inp ++ p2 inp
                                                                                         |                                                                                                                                        |
-- In Tanager, all of the type annotations are *optional*                                | -- In Motmot, type annotations are compulsory any time that                                                                            |
-- (but are good style for top-level bindings and                                        | -- a name is introduced (when creating a binding, in                                                                                   |
-- `where`-bound functions.                                                              | -- patterns, etc.).                                                                                                                    |
<=>       : Parser a -> Parser b -> Parser (a, b)                                        | <=>                                 : (a : *) => (b : *) => Parser a -> Parser b -> Parser (a, b)                                      | <=> : (a : *) => (b : *) => Parser a -> Parser b -> Parser (a, b) =
... p1 p2 = p1 >>                                                                        | ... (p1 : Parser a) (p2 : Parser b) = p1 >>                                                                                            |   (a : *) => (b : *) =>
              concatMap core                                                             |                                         concat-map core                                                                                |     (p1 : Parser a) | (p2 : Parser b) ~
            where core           : (a, Letters) -> [ ((a, b), Letters) ]                 |                                       where core                             : (a, Letters) -> [ ((a, b), Letters) ]                   |       p1 >>
                  ... (v1, out1) = out1 |>                                               |                                             ... ((v1 : a), (out1 : Letters)) = out1 |>                                                 |       concat-map (((v1 : a), (out1 : Letters)) ~ out1 |>
                                     p2 >>                                               |                                                                                  p2 >>                                                 |                                                    p2 >>
                                     map (\ (v2, out2) -> ((v1, v2), out2))              |                                                                                  map (((v2 : b), (out2 : Letters)) ~ ((v1, v2), out2)) |                                                    map (((v2 : b), (out2 : Letters)) ~ ((v1, v2), out2))
                                                                                         |                                                                                                                                        |
>>>     : Parser a -> (a -> b) -> Parser b                                               | >>>                             : (a : *) => (b : *) => Parser a -> (a -> b) -> Parser b                                               | >>> : (a : *) => (b : *) => Parser a -> (a -> b) -> Parser b =
... p f = p >> map (first f)                                                             | ... (p : Parser a) (f : a -> b) = p >> map (first{ Letters } f)                                                                        |   (a : *) => (b : *) =>
                                                                                         |                                                                                                                                        |     (p : Parser a) | (f : a -> b) ~
                                                                                         |                                                                                                                                        |       p >> map (first{ Letters } f)
                                                                                         |                                                                                                                                        |
many  : Parser a -> Parser [ a ]                                                         | many               : (a : *) => Parser a -> Parser [ a ]                                                                               | many : (a : *) => Parser a -> Parser [ a ] =
... p = (p <=> (\ inp -> many p inp) >>> uncurry2 (_ :: _)) || succeed []                | ... (p : Parser a) = (p <=> ((inp : Letters) ~ many p inp) >>> uncurry (::{ a })) || succeed [{ a }]                                   |   (a : *) =>
                                                                                         |                                                                                                                                        |     (p : Parser a) ~ (p <=> ((inp : Letters) ~ many p inp) >>> uncurry (::{ a })) || succeed [{ a }]
                                                                                         |                                                                                                                                        |
some  : Parser a -> Parser [ a ]                                                         | some               : (a : *) => Parser a -> Parser [ a ]                                                                               | some : (a : *) => Parser a -> Parser [ a ] =
... p = p <=> many p >>> uncurry2 (_ :: _)                                               | ... (p : Parser a) = p <=> many p >>> uncurry (::{ a })                                                                                |   (a : *) =>
                                                                                         |                                                                                                                                        |     (p : Parser a) ~
                                                                                         |                                                                                                                                        |       p <=> many p >>> uncurry (::{ a })
                                                                                         |                                                                                                                                        |
                                                                                         | -- Motmot uses `=<` for symmetry with `>=`.                                                                                            |
                                                                                         | -- Motmot has `$`-delimited strings for reasons.                                                                                       |
number : Parser String                                                                   | number : Parser String                                                                                                                 | number : Parser String =
...    = some (satisfy digit) >>> implode                                                | ...    = some (satisfy digit) >>> implode                                                                                              |   some (satisfy digit) >>> implode
         where digit = ("0" <= _) and^ (_ <= "9")                                        |          where (digit : String -> Bool) = ($0$ =< _) and^ (_ =< $9$)                                                                   |   where (digit : String -> Bool) = ($0$ =< _) and^ (_ =< $9$)
                                                                                         |                                                                                                                                        |
word : Parser String                                                                     | word : Parser String                                                                                                                   | word : Parser String =
...  = some (satisfy letter) >>> implode                                                 | ...  = some (satisfy letter) >>> implode                                                                                               |   some (satisfy letter) >>> implode
       where letter : String -> Bool                                                     |        where letter : String -> Bool                                                                                                   |   where (letter : String -> Bool) = lowercase >>
             ...    = lowercase >>                                                       |              ...    = lowercase >>                                                                                                     |                                     ($a$ =< _) and^ (_ =< $z$)
                      ("a" <= _) and^ (_ <= "z")                                         |                         ($a$ =< _) and^ (_ =< $z$)                                                                                     |
                                                                                         |                                                                                                                                        |
string : String -> Parser String                                                         | string : String -> Parser String                                                                                                       | string : String -> Parser String =
...    = explode >> core                                                                 | ...    = explode >> core                                                                                                               |   explode >> core
         where core          : [ String ] -> Parser String                               |          where core                                    : [ String ] -> Parser String                                                   |   where (core : [ String ] -> Parser String) = case of
               ... []        = succeed ""                                                |                ... [{ String }]                        = succeed $$                                                                    |                                                ([{ String }]                      ~ succeed $$)
               ... (x :: xs) = literal x <=> core xs >>> uncurry2 (#)                    |                ... ((x : String) :: (xs : [ String ])) = literal x <=> core xs >>> uncurry (#)                                         |                                                ((x : String) :: (xs : [ String ]) ~ literal x <=> core xs >>> uncurry (#))
                                                                                         |                                                                                                                                        |
==>       : Parser a -> Parser b -> Parser b                                             | ==>                                 : (a : *) => (b : *) => Parser a -> Parser b -> Parser b                                           | ==> : (a : *) => (b : *) => Parser a -> Parser b -> Parser b =
... p1 p2 = p1 <=> p2 >>> snd                                                            | ... (p1 : Parser a) (p2 : Parser b) = p1 <=> p2 >>> snd{ a, b }                                                                        |   (a : *) => (b : *) =>
                                                                                         |                                                                                                                                        |     (p1 : Parser a) | (p2 : Parser b) ~
                                                                                         |                                                                                                                                        |       p1 <=> p2 >>> snd{ a, b }
                                                                                         |                                                                                                                                        |
<==       : Parser a -> Parser b -> Parser a                                             | <==                                 : (a : *) => (b : *) => Parser a -> Parser b -> Parser a                                           | <== : (a : *) => (b : *) => Parser a -> Parser b -> Parser a =
... p1 p2 = p1 <=> p2 >>> fst                                                            | ... (p1 : Parser a) (p2 : Parser b) = p1 <=> p2 >>> fst{ a, b }                                                                        |   (a : *) => (b : *) =>
                                                                                         |                                                                                                                                        |     (p1 : Parser a) | (p2 : Parser b) ~
                                                                                         |                                                                                                                                        |       p1 <=> p2 >>> fst{ a, b }
                                                                                         |                                                                                                                                        |
return  : Parser a -> b -> Parser b                                                      | return                     : (a : *) => (b : *) => Parser a -> b -> Parser b                                                           | return : (a : *) => (b : *) => Parser a -> b -> Parser b =
... p v = p >>> const v                                                                  | ... (p : Parser a) (v : b) = p >>> const{ a } v                                                                                        |   (a : *) => (b : *) =>
                                                                                         |                                                                                                                                        |     (p : Parser a) | (v : b) ~ p >>> const{ a } v
                                                                                         |                                                                                                                                        |
new data Expr = Num Num                                                                  | new data Expr = Num Num                                                                                                                | axiom Expr : *
                Add Expr Expr                                                            |                 Add Expr Expr                                                                                                          | axiom Num  : Num -> Expr
                Sub Expr Expr                                                            |                 Sub Expr Expr                                                                                                          | axiom Add  : Expr -> Expr -> Expr
                Mul Expr Expr                                                            |                 Mul Expr Expr                                                                                                          | axiom Sub  : Expr -> Expr -> Expr
                Div Expr Expr                                                            |                 Div Expr Expr                                                                                                          | axiom Mul  : Expr -> Expr -> Expr
                                                                                         |                                                                                                                                        | axiom Div  : Expr -> Expr -> Expr
                                                                                         |                                                                                                                                        |
value : String -> Expr                                                                   | value : String -> Expr                                                                                                                 | value : String -> Expr = read{ Num } >> Num
...   = read >> Num                                                                      | ...   = read{ Num } >> Num                                                                                                             |
                                                                                         |                                                                                                                                        |
plus : (Expr, Expr) -> Expr                                                              | plus : (Expr, Expr) -> Expr                                                                                                            | plus : (Expr, Expr) -> Expr = uncurry Add
...  = uncurry2 Add                                                                      | ...  = uncurry Add                                                                                                                     |
                                                                                         |                                                                                                                                        |
minus : (Expr, Expr) -> Expr                                                             | minus : (Expr, Expr) -> Expr                                                                                                           | minus : (Expr, Expr) -> Expr = uncurry Sub
...   = uncurry2 Sub                                                                     | ...   = uncurry Sub                                                                                                                    |
                                                                                         |                                                                                                                                        |
times : (Expr, Expr) -> Expr                                                             | times : (Expr, Expr) -> Expr                                                                                                           | times : (Expr, Expr) -> Expr = uncurry Mul
...   = uncurry2 Mul                                                                     | ...   = uncurry Mul                                                                                                                    |
                                                                                         |                                                                                                                                        |
divide : (Expr, Expr) -> Expr                                                            | divide : (Expr, Expr) -> Expr                                                                                                          | divide : (Expr, Expr) -> Expr = uncurry Div
...    = uncurry2 Div                                                                    | ...    = uncurry Div                                                                                                                   |
                                                                                         |                                                                                                                                        |
-- The Tanager has to be refactored because top-level                                    |                                                                                                                                        |
-- bindings aren't mutually-recursive.                                                   |                                                                                                                                        |
expn : Parser Expr                                                                       | expn : Parser Expr                                                                                                                     | expn : Parser Expr =
...  = (term <== literal "+" <=> (\ inp -> expn inp) >>> plus) ||                        | ...  = (term <== literal $+$ <=> ((inp : Letters) ~ expn inp) >>> plus) ||                                                             |   (term <== literal $+$ <=> ((inp : Letters) ~ expn inp) >>> plus) ||
         (\ inp -> (term <== literal "-" <=> term >>> minus) inp) ||                     |          ((inp : Letters) ~ (term <== literal $-$ <=> term >>> minus) inp) ||                                                          |     ((inp : Letters) ~ (term <== literal $-$ <=> term >>> minus) inp) ||
         (\ inp -> term inp)                                                             |          ((inp : Letters) ~ term inp)                                                                                                  |     ((inp : Letters) ~ term inp)
       where term   : Parser Expr                                                        |                                                                                                                                        |
             ...    = (factor <== literal "*" <=> (\ inp -> term inp) >>> times) ||      | term : Parser Expr                                                                                                                     | term : Parser Expr =
                        (\ inp -> (factor <== literal "/" <=> factor >>> divide) inp) || | ...  = (factor <== literal $*$ <=> ((inp : Letters) ~ term inp) >>> times) ||                                                          |   (factor <== literal $*$ <=> ((inp : Letters) ~ term inp) >>> times) ||
                        (\ inp -> factor inp)                                            |          ((inp : Letters) ~ (factor <== literal $/$ <=> factor >>> divide) inp) ||                                                     |     ((inp : Letters) ~ (factor <== literal $/$ <=> factor >>> divide) inp) ||
             factor : Parser Expr                                                        |          ((inp : Letters) ~ factor inp)                                                                                                |     ((inp : Letters) ~ factor inp)
             ...    = (number >>> value) ||                                              |                                                                                                                                        |
                        (\ inp -> (literal "(" ==> expn <== literal ")") inp)            | factor : Parser Expr                                                                                                                   | factor : Parser Expr =
                                                                                         | ...    = (number >>> value) ||                                                                                                         |   (number >>> value) ||
                                                                                         |            ((inp : Letters) ~ (literal $($ ==> expn <== literal $)$) inp)                                                              |     ((inp : Letters) ~ (literal $($ ==> expn <== literal $)$) inp)
