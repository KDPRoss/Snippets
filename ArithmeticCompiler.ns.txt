PRAGMA Tanager4
PRAGMA Library Demo.ArithmeticCompiler

-- Simple Arithmetic 'Compiler' in Tanager            --
--                                                    --
-- Copyright 2015-2016 K.D.P.Ross <KDPRoss@gmail.com> --
--                                                    --
-- This code is licensed only for study and personal  --
-- enrichment.                                        --



-- /------------------------------------------\
-- | ‘The raison  d'être  of a program  is to |
-- | be  a  mathematically-elegant  object of |
-- | sublime beauty; it's also pretty cool if |
-- | it  occasionally   computes  something.’ |
-- |                             - K.D.P.Ross |
-- \------------------------------------------/



-- Trivial 'compiler' for arithmetic trees to arithmetic
-- stacks; based on an exercise from Simon Peyton-Jones.



topLevel|loadFile "DDParse.ns.txt"

-- ========== Source Language ========== --

new type SourceExp : *
new cons SNum      : Num -> SourceExp
new cons SAdd      : SourceExp -> SourceExp -> SourceExp
new cons SMul      : SourceExp -> SourceExp -> SourceExp

module source where
  showExp : SourceExp -> String
  ... (SNum n)    = showProperFraction n
  ... (SAdd e e') = parenthesise $$ showExp e # " + " # showExp e'
  ... (SMul e e') = parenthesise $$ showExp e # " * " # showExp e'



-- ========== Recursive Interpreter ========== --

module interpret where
  run : SourceExp -> Num
  ... (SNum n)    = n
  ... (SAdd e e') = run e + run e'
  ... (SMul e e') = run e * run e'



-- ========== Target Language ========== --

new type TargetExp : *
new cons TNum      : Num -> TargetExp
new cons TAdd      : TargetExp
new cons TMul      : TargetExp

module target where
  showExp : TargetExp -> String
  ... (TNum n) = showProperFraction n
  ... TAdd     = "+"
  ... TMul     = "*"



-- ========== Translator / Execution Machine ========== --

module compile where
  translate : SourceExp -> [ TargetExp ]
  ... (SNum n)    = [ TNum n ]
  ... (SAdd e e') = translate e ++ translate e' :@ TAdd
  ... (SMul e e') = translate e ++ translate e' :@ TMul

  run : [ TargetExp ] -> Num
  ... = let strict cheekyShow = show >> ("  " # _) >> printEndline >> const Nothing
                   message    = around "    <" ">" >> printEndline
        fun loop instr (stack -> []) where
        | cheekyShow \ Just _                 -> fail "Impossible."
                                                 -- Yes, this is *extremely* cheeky 0:~P
        | (TNum n :: instr, _)                -> message "pushing num"
                                                 ; loop instr (n :: stack)
        | (TAdd :: instr,   n :: n' :: stack) -> message "adding top 2 el'ts on stack"
                                                 ; loop instr (n + n' :: stack)
        | (TMul :: instr,   n :: n' :: stack) -> message "multiplying top 2 el'ts on stack"
                                                 ; loop instr (n * n' :: stack)
        | ([],              [ n ])            -> message "final state"
                                                 ; n
        | _                                   -> message "STUCK STATE"
                                                 ; fail "Bad program."



-- ========== Parser ========== --

module parser with monad, comb, parse exports parser as run where
  <      = left
  >      = right
  <| p q = p < const q
  |> p q = p > const q

  parseNum : Parser SourceExp
  ... = (many1 (sat ((_ >= "0") and^ (_ <= "9"))) `post` toNum)
        where toNum = implode >> read >> SNum

  parseSexp : Parser SourceExp
  ... = parseNum + bracketed
        where bracketed = word "(" > $$ \ _ -> parseAdd <| word ")"

  parseMul : Parser SourceExp
  ... = parseMulProper + parseSexp
        where parseMulProper = (parseSexp <| spaces <| word "*") * (\ _ -> spaces |> parseMul) `post` uncurry2 SMul

  parseAdd : Parser SourceExp
  ... = parseAddProper + parseMul
        where parseAddProper = (parseMul <| spaces <| word "+") * (\ _ -> spaces |> parseAdd) `post` uncurry2 SAdd

  parseExp : Parser SourceExp
  ... = maybe spaces > $$ \ _ -> parseAdd <| maybe spaces <| eof

  parser s = case (explode >> parseExp) s of
             | ~ []
             | ~ _ :: _ :: _
             | [ (res, []) ] -> res



-- ========== Tie It All Together ========== --

module rep where
  run : String -> ()
  ... s = printEndline <| "Input:       " # s
          ; printEndline <| "Parsed:      " # source.showExp sExp
          ; printEndline <| "Interpreted: " # showProperFraction iRes
          ; printEndline <| "Compiled:    " # tStr
          ; printEndline <| "Result:      " # showProperFraction res
          where sExp = parser.run s
                tExp = compile.translate sExp
                res  = printEndline "Running:"
                       ; compile.run tExp
                iRes = interpret.run sExp
                tStr = tExp |> map target.showExp >> intersperse ", " >> implode >> around "[ " " ]"

main = rep.run
