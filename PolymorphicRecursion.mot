#MotmotF

┌────────────────────────────────────────────────────────┐
│ Polymorphic recursion in Motmot based on examples from │
│ ‘Programming Examples Needing Polymorphic Recursion’   │
│ (J.J.Hallett and A.J.Kfoury, 2004)                     │
│                                                        │
│ Copyright 2020-2026 K.D.P.Ross <KDPRoss@gmail.com>     │
│                                                        │
│ This code is licensed only for study and personal      │
│ enrichment.                                            │
└────────────────────────────────────────────────────────┘


│ Relevant resources:
│ - the original paper: tinyurl.com/y49cupss


┌──────────────────────────────────────────┐
│ ‘The raison  d'être  of a program  is to │
│ be  a  mathematically-elegant  object of │
│ sublime beauty; it's also pretty cool if │
│ it  occasionally   computes  something.’ │
│                             - K.D.P.Ross │
└──────────────────────────────────────────┘


{-- Demo.PolymorphicRecursion --}

│ (§3.1.1)

double-coupled : (String, Num) =
  (foo $foo$, goo 1)
  where double : a => (a -> a) -> a -> a =
          a =>
            f : a -> a ~ x : a ~
              f (f x)
      | foo : String -> String =
          double (_ # $+1$)
      | goo : Num -> Num =
          double (_ + 1)

│ (§3.2.1)

mycroft-coupled : ([ Num ], [ Bool ]) =
  (sq-list [ 2, 4 ], comp-list [ True, False ])
  where my-map : a => (a -> a) -> [ a ] -> [ a ] =
          a =>
            f : a -> a ~ l : [ a ] ~
              if List.empty? l
                 then l
                 else f (List.head l) :: my-map f (List.tail l)
      | sq-list : [ Num ] -> [ Num ] =
          my-map (_ ^ 2)
      | comp-list : [ Bool ] -> [ Bool ] =
          my-map not

│ Here's a more Motmotastic pattern-matching version:

mycroft-coupled' : ([ Num ], [ Bool ]) =
  (sq-list [ 2, 4 ], comp-list [ True, False ])
  where my-map : a => (a -> a) -> [ a ] -> [ a ] =
          a =>
            f : a -> a ~
              fun
              ([{ a }]             ~ [{ a }])
              (l : a :: ls : [ a ] ~ f l :: my-map f ls)
      | sq-list : [ Num ] -> [ Num ] =
          my-map (_ ^ 2)
      | comp-list : [ Bool ] -> [ Bool ] =
          my-map not

│ (§3.3)

sum-list : Num =
  sum-list [ 1 .. 3 ]
  where id : a => a -> a =
          a =>
            x : a ~
              x
      | sum-list : [ Num ] -> Num =
          l : [ Num ] ~
            if List.empty? l
               then 0
               else id (List.head l) + sum-list (id (List.tail l))

│ Here's a more Motmotastic clausal version:

sum-list' : Num =
  sum-list [ 1 .. 3 ]
  where id : a => a -> a =
          a =>
            x : a ~
              x
      | sum-list : [ Num ] -> Num =
          fun
          ([{ Num }]               ~ 0)
          (l : Num :: ls : [ Num ] ~ id l + sum-list (id ls))

│ (§3.4)

isomorphic-composition : Bool =
  app-comp 5 [ 5 ]
  where create-list : a => a -> [ a ] =
          a =>
            x : a ~
              [ x ]
      | remove-list : a => [ a ] -> a =
          a =>
            x : a :: _ : [ a ] ~
              x
      | comp : (a, b, c) => (b -> c) -> (a -> b) -> a -> c =
          (a, b, c) =>
            g : b -> c ~ f : a -> b ~
              f >> g
      | app-comp : a => a -> [ a ] -> Bool =
          a =>
            x : a ~ xs : [ a ] ~
              comp remove-list{ a } create-list{ a } x == List.head (comp create-list{ a } remove-list{ a } xs)

│ (§4.1.1)

matrix-transpose : [ [ Num ] ] =
  map'' map' [ [ 1, 2 ], [ 3, 4 ] ]
  where map' : (a, b) => (a -> b) -> [ a ] -> [ b ] =
          List.map
      | map'' : a => ((a, b) => (a -> b) -> [ a ] -> [ b ]) -> [ [ a ] ] -> [ [ a ] ] =
          a =>
            f : (a, b) => (a -> b) -> [ a ] -> [ b ] ~ l : [ [ a ] ] ~
              cases
              (List.empty? l             ~ [{ [ a ] }])
              (List.empty? (List.head l) ~ [{ [ a ] }])
              (_                         ~ f List.head{ a } l :: map'' f (f List.tail{ a } l))

│ Here's a more Motmotastic pattern-matching version:

matrix-transpose' : [ [ Num ] ] =
  map'' map' [ [ 1, 2 ], [ 3, 4 ] ]
  where map' : (a, b) => (a -> b) -> [ a ] -> [ b ] =
          List.map
      | map'' : a => ((a, b) => (a -> b) -> [ a ] -> [ b ]) -> [ [ a ] ] -> [ [ a ] ] =
          a =>
            f : (a, b) => (a -> b) -> [ a ] -> [ b ] ~
              fun
              ([{ [ a ] }] or
               [{ a }] :: _ : [ [ a ] ] ~ [{ [ a ] }]
              )
              (l : [ [ a ] ]            ~ f List.head{ a } l :: map'' f (f List.tail{ a } l) )

│ (§5.1)

axiom T     : * -> *
axiom Empty : a => T a
axiom Node  : a => a -> (T (T a)) -> T a

collect : [ Num ] =
  collect (Node 3 (Node (Node 4 Empty{ T Num }) Empty{ T (T Num) }))
  where collect : a => T a -> [ a ] =
          a =>
            fun
            (Empty{ a }                 ~ [{ a }])
            (Node (n : a) (t : T (T a)) ~ n :: List.concat-map collect{ a } (collect t))

│ (§5.2)

bar : Num =
  bar 1 f a
  where a = 5
      | r : Num -> Bool =
          (_ >= 4)
      | f : Num -> Num =
          (_ * 2)
      | bar : a => Num -> (a -> a) -> a -> a =
          a =>
            x : Num ~ f' : a -> a ~ z : a ~
              if r x
                 then f' z
                 else bar{ a -> a } (f x) (v : a -> a ~
                        v >> v
                      ) f' z

│ (§6.1)

construct-list : ([ [ Num ] ], [ [ Bool ] ]) =
  apply-cl [ 1 .. 3 ] [ True, False, True ] List.length
  where cons-list : a => a -> Num -> [ a ] =
          a =>
            x : a ~ n : Num ~
              if 0 == n
                 then [ x, x ]
                 else x :: List.tail (List.concat (cons-list (cons-list x (n - 1)) (n - 1)))
      | apply-cl : (a, b) => [ a ] -> [ b ] -> (c => [ c ] -> Num) -> ([ [ a ] ], [ [ b ] ]) =
          (a, b) =>
            l1 : [ a ] ~ l2 : [ b ] ~ f : c => [ c ] -> Num ~
              (cons-list l1 (f l1), cons-list l2 (f l2))

│ Here's a more Motmotastic clausal version:

construct-list' : ([ [ Num ] ], [ [ Bool ] ]) =
  apply-cl [ 1 .. 3 ] [ True, False, True ] List.length
  where cons-list : a => a -> Num -> [ a ] =
          a =>
            x : a ~
              fun
              (0       ~ [ x, x ])
              (n : Num ~ x :: List.tail (List.concat (cons-list (cons-list x (n - 1)) (n - 1))))
      | apply-cl : (a, b) => [ a ] -> [ b ] -> (c => [ c ] -> Num) -> ([ [ a ] ], [ [ b ] ]) =
          (a, b) =>
            l1 : [ a ] ~ l2 : [ b ] ~ f : c => [ c ] -> Num ~
              (cons-list l1 (f l1), cons-list l2 (f l2))

{-end- Demo.PolymorphicRecursion --}
